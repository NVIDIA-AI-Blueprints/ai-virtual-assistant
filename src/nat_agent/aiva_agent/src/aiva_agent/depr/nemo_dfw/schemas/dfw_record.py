# SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
from enum import Enum
from typing import Literal

from pydantic import BaseModel
from pydantic import Field

logger = logging.getLogger(__name__)


class FinishReason(Enum):
    TOOL_CALLS = "tool_calls"
    STOP = "stop"


class Role(Enum):
    HUMAN = "human"
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"
    AI = "ai"
    TOOL = "tool"


class Function(BaseModel):
    arguments: dict = Field(
        ..., description="The arguments to call the function with, as generated by the model in JSON format."
    )
    name: str = Field(..., description="The name of the function to call.")


class FunctionCall(BaseModel):
    name: str | None = None
    arguments: str | None = None


class MessageToolCall(BaseModel):
    id: str = Field(..., description="The ID of the tool call.")
    function: Function = Field(..., description="The function that the model called.")
    type_: Literal["function"] = Field(
        ..., description="The type of the tool. Currently, only `function` is supported.", alias="type")


class AssistantMessage(BaseModel):
    role: Literal["assistant", "ai"] = Field(..., 
                                             description="The role of the messages author, in this case `assistant`.")
    content: str | None = Field(default=None, description="The contents of the assistant message.")
    function_call: FunctionCall | None = Field(default=None, description="Deprecated and replaced by `tool_calls`.")
    tool_calls: list[MessageToolCall] | None = Field(
        default=None, description="The tool calls generated by the model, such as function calls."
    )


class SystemMessage(BaseModel):
    content: str = Field(..., description="The contents of the system message.")
    role: Literal["system"] = Field(..., description="The role of the messages author, in this case `system`.")


class UserMessage(BaseModel):
    content: str = Field(
        ..., description="The contents of the user message."
    )
    role: Literal["user", "human"] = Field(..., description="The role of the messages author, in this case `user`.")


class ToolMessage(BaseModel):
    content: str = Field(..., description="The contents of the tool message.")
    role: Literal["tool"] = Field(..., description="The role of the messages author, in this case `tool`.")
    tool_call_id: str = Field(..., description="Tool call that this message is responding to.")


class FunctionMessage(BaseModel):
    content: str | None = Field(default=None, description="The contents of the function message.")
    role: Literal["function", "chain"] = Field(..., description="The role of the messages author, in this case `function`.")


Message = (
    SystemMessage |
    UserMessage |
    AssistantMessage |
    ToolMessage |
    FunctionMessage
)

class FunctionParameters(BaseModel):
    properties: dict = Field(..., description="The properties of the function parameters.")
    required: list[str] = Field(..., description="The required properties of the function parameters.")
    type_: Literal["object"] = Field(default="object", description="The type of the function parameters.", alias="type")


class FunctionDetails(BaseModel):
    name: str = Field(..., description="The name of the function.")
    description: str = Field(..., description="The description of the function.")
    parameters: FunctionParameters = Field(..., description="The parameters of the function.")


class RequestTool(BaseModel):
    type: Literal["function"] = Field(..., description="The type of the tool.")
    function: FunctionDetails = Field(..., description="The function details.")


class Request(BaseModel):
    tools: list[RequestTool] | None = Field(default=None, description="The tool choice.")
    messages: list[Message] | None = Field(default=None, description="The messages.")
    model: str = Field(default="", description="The model to use.")


class ChoiceMessageToolCallFunction(BaseModel):
    name: str | None = Field(default=None, description="The name of the function.")
    arguments: dict | None = Field(
        default=None, 
        description="The arguments to call the function with, as generated by the model in JSON format.")


class ChoiceMessageToolCall(BaseModel):
    function: ChoiceMessageToolCallFunction | None = Field(
        default=None, description="The function details.")
    type_: Literal["function", "chain", "tool"] | None = Field(
        default=None, description="The type of the tool call.", alias="type")


class ChoiceResponseMessage(BaseModel):
    role: Literal["system", "user", "human", "assistant", "tool", "function", "chain"] | None = None
    content: str | None = None
    tool_calls: list[ChoiceMessageToolCall] | None = Field(
        default=None,
        description="The tool calls generated by the model, such as function calls."
    )


class ResponseChoice(BaseModel):
    message: ChoiceResponseMessage = Field(
        ...,
        description="A chat completion message generated by the model."
    )


class Response(BaseModel):
    choices: list[ResponseChoice] | None = Field(default=None, description="The choices.")


class NemoDFWRecord(BaseModel):
    request: Request | None = Field(default=None)
    response: Response | None = Field(default=None)
    client_id: str | None = Field(default=None)
    workload_id: str | None = Field(default=None)
    timestamp: int = Field(..., description="The timestamp of the payload in milliseconds since epoch.")
